<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libting: atomic.hpp File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libting
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
      <li><a href="annotated.htm"><span>Classes</span></a></li>
      <li class="current"><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.htm"><span>File&#160;List</span></a></li>
      <li><a href="globals.htm"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('atomic_8hpp.htm','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">atomic.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="config_8hpp_source.htm">config.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="debug_8hpp_source.htm">debug.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="types_8hpp_source.htm">types.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="util_8hpp_source.htm">util.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Thread_8hpp_source.htm">mt/Thread.hpp</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="Mutex_8hpp_source.htm">mt/Mutex.hpp</a>&quot;</code><br/>
</div>
<p><a href="atomic_8hpp_source.htm">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1atomic_1_1Flag.htm">ting::atomic::Flag</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic flag.  <a href="classting_1_1atomic_1_1Flag.htm#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1atomic_1_1SpinLock.htm">ting::atomic::SpinLock</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Spinlock class.  <a href="classting_1_1atomic_1_1SpinLock.htm#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1atomic_1_1SpinLock_1_1Guard.htm">ting::atomic::SpinLock::Guard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which automatically Locks the given spinlock.  <a href="classting_1_1atomic_1_1SpinLock_1_1Guard.htm#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1atomic_1_1SpinLock_1_1GuardYield.htm">ting::atomic::SpinLock::GuardYield</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which automatically Locks the given spinlock.  <a href="classting_1_1atomic_1_1SpinLock_1_1GuardYield.htm#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGuard.htm">Guard</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which automatically Locks the given spinlock.  <a href="classGuard.htm#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGuardYield.htm">GuardYield</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class which automatically Locks the given spinlock.  <a href="classGuardYield.htm#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1atomic_1_1S32.htm">ting::atomic::S32</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic signed 32bit integer.  <a href="classting_1_1atomic_1_1S32.htm#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1atomic_1_1U32.htm">ting::atomic::U32</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic unsigned 32bit integer.  <a href="classting_1_1atomic_1_1U32.htm#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceting.htm">ting</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>buffer wrapper class and static buffer wrapper. </p>
<br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceting_1_1atomic.htm">ting::atomic</a></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a45ee8aa512a0fb53616a19c2675d156f">M_ATOMIC_USE_MUTEX_FALLBACK</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic operations.  <a href="#a45ee8aa512a0fb53616a19c2675d156f"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classting_1_1atomic_1_1Flag.htm">ting::atomic::Flag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceting_1_1atomic.htm#acfc4037f2a876b6ddf25cc6644fe6572">ting::atomic::M_DECLARE_ALIGNED</a> (sizeof(int))</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a1c982003f982bb0e493355ece02be543">Flag</a> (bool initialValue=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a1c982003f982bb0e493355ece02be543"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a15a615a74f3e3329f9cc804a91f0dc4b">Get</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current flag value.  <a href="#a15a615a74f3e3329f9cc804a91f0dc4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a3e8cb0d2b3219a3298cded0fdde3426b">Set</a> (bool value=true)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flag value.  <a href="#a3e8cb0d2b3219a3298cded0fdde3426b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#ac4cd494ca5b8dac7d0589fbe7dfc7765">SetAcquire</a> (bool value=true)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flag value with acquire memory semantics.  <a href="#ac4cd494ca5b8dac7d0589fbe7dfc7765"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a4074a0fc21ee0638e21297c897489a9e">SetRelease</a> (bool value=true)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the flag value with release memory semantics.  <a href="#a4074a0fc21ee0638e21297c897489a9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a66d6af9d533c2d082d0066389ab820ad">Clear</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear flag.  <a href="#a66d6af9d533c2d082d0066389ab820ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a19f4bcf8ff5c4b0d8574c7bd196e3ecf">ClearAcquire</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear flag with acquire memory semantics.  <a href="#a19f4bcf8ff5c4b0d8574c7bd196e3ecf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a7802cde90b333bbfaa5aba92d092c654">ClearRelease</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear flag with release memory semantics.  <a href="#a7802cde90b333bbfaa5aba92d092c654"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a6ce59eb01b0e6ba0ca3f7ffbde486c40">SpinLock</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a6ce59eb01b0e6ba0ca3f7ffbde486c40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a5b098764879fab720c0895ab3ec10da7">Lock</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the spinlock.  <a href="#a5b098764879fab720c0895ab3ec10da7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#af8889cad23a39a688422bd7a39cb7425">LockYield</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock the spinlock.  <a href="#af8889cad23a39a688422bd7a39cb7425"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#ae6130bfda1ed3a246f6f26c7cb42a439">Unlock</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the spinlock.  <a href="#ae6130bfda1ed3a246f6f26c7cb42a439"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a287b07ab58356e40b664415069dae742">S32</a> (<a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> initialValue=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a287b07ab58356e40b664415069dae742"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#ae76479f8a15a8ecad9b0e9708f022119">~S32</a> ()  throw ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a5b9655568a9dd6b29a402c6e42c0e887">FetchAndAdd</a> (<a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the value to this atomic variable and returns its initial value.  <a href="#a5b9655568a9dd6b29a402c6e42c0e887"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#ac6f76ca7faea2e43296c93756852c1a9">FetchAndAddAcquire</a> (<a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the value to this atomic variable and returns its initial value.  <a href="#ac6f76ca7faea2e43296c93756852c1a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#ace2b9979e51bad5df8c3edcfa637547b">FetchAndAddRelease</a> (<a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> value)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the value to this atomic variable and returns its initial value.  <a href="#ace2b9979e51bad5df8c3edcfa637547b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#ac51538cd69d8c6ebe26332e93160d2a0">CompareAndExchange</a> (<a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> compareTo, <a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> exchangeBy)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and exchange operation.  <a href="#ac51538cd69d8c6ebe26332e93160d2a0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#af7922ff883503de1d13af79cbe7e715d">CompareAndExchangeAcquire</a> (<a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> compareTo, <a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> exchangeBy)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and exchange operation.  <a href="#af7922ff883503de1d13af79cbe7e715d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a8beb457e5846624c3d2e8fc1d9956a28">CompareAndExchangeRelease</a> (<a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> compareTo, <a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> exchangeBy)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic compare and exchange operation.  <a href="#a8beb457e5846624c3d2e8fc1d9956a28"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classting_1_1mt_1_1Mutex.htm">ting::mt::Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a6334cfeab8b0e3af50dc82ebca4431bf">mutex</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a606c82003e3aa49e5baad6ad20278bbe">flag</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="atomic_8hpp.htm#a6ce59eb01b0e6ba0ca3f7ffbde486c40">atomic::SpinLock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#afe48ce163895a0bb972cda1b8046e6d9">spinLock</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile <a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="atomic_8hpp.htm#a06cc42a46c3f1cdf8c7f856fe28fc463">v</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class <a class="el" href="classting_1_1atomic_1_1U32.htm">ting::atomic::U32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceting_1_1atomic.htm#aa513f535e5ad73140599e383eb04f7eb">ting::atomic::M_DECLARE_ALIGNED</a></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="a45ee8aa512a0fb53616a19c2675d156f"></a><!-- doxytag: member="atomic.hpp::M_ATOMIC_USE_MUTEX_FALLBACK" ref="a45ee8aa512a0fb53616a19c2675d156f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="atomic_8hpp.htm#a45ee8aa512a0fb53616a19c2675d156f">M_ATOMIC_USE_MUTEX_FALLBACK</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomic operations. </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Ivan Gagis &lt;<a href="mailto:igagis@gmail.com">igagis@gmail.com</a>&gt; </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a66d6af9d533c2d082d0066389ab820ad"></a><!-- doxytag: member="atomic.hpp::Clear" ref="a66d6af9d533c2d082d0066389ab820ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="atomic_8hpp.htm#a66d6af9d533c2d082d0066389ab820ad">M_DECLARE_ALIGNED::Clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear flag. </p>
<p>Basically, it is equivalent to Flag::Set(false), but on some architectures its implementation can be faster. It does not set any memory barrier. </p>

</div>
</div>
<a class="anchor" id="a19f4bcf8ff5c4b0d8574c7bd196e3ecf"></a><!-- doxytag: member="atomic.hpp::ClearAcquire" ref="a19f4bcf8ff5c4b0d8574c7bd196e3ecf" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="atomic_8hpp.htm#a19f4bcf8ff5c4b0d8574c7bd196e3ecf">M_DECLARE_ALIGNED::ClearAcquire</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear flag with acquire memory semantics. </p>
<p>Basically, it is equivalent to Flag::Set(false), but on some architectures its implementation can be faster. It sets acquire memory semantics barrier. It means that on weakly ordered architectures memory access operations which go after the <a class="el" href="atomic_8hpp.htm#a19f4bcf8ff5c4b0d8574c7bd196e3ecf" title="Clear flag with acquire memory semantics.">ClearAcquire()</a> will be executed exactly after it. </p>

</div>
</div>
<a class="anchor" id="a7802cde90b333bbfaa5aba92d092c654"></a><!-- doxytag: member="atomic.hpp::ClearRelease" ref="a7802cde90b333bbfaa5aba92d092c654" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="atomic_8hpp.htm#a7802cde90b333bbfaa5aba92d092c654">M_DECLARE_ALIGNED::ClearRelease</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clear flag with release memory semantics. </p>
<p>Basically, it is equivalent to Flag::Set(false), but on some architectures its implementation can be faster. It sets release memory semantics barrier. It means that on weakly ordered architectures memory access operations which go before the <a class="el" href="atomic_8hpp.htm#a7802cde90b333bbfaa5aba92d092c654" title="Clear flag with release memory semantics.">ClearRelease()</a> will be executed exactly before it. </p>

</div>
</div>
<a class="anchor" id="ac51538cd69d8c6ebe26332e93160d2a0"></a><!-- doxytag: member="atomic.hpp::CompareAndExchange" ref="ac51538cd69d8c6ebe26332e93160d2a0" args="(ting::s32 compareTo, ting::s32 exchangeBy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> <a class="el" href="atomic_8hpp.htm#ac51538cd69d8c6ebe26332e93160d2a0">M_DECLARE_ALIGNED::CompareAndExchange</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>compareTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>exchangeBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomic compare and exchange operation. </p>
<p>Compares the current value to the 'compareTo' value and if they are equal it will store the 'exchangeBy' value to the current value. It does not set any memory barrier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compareTo</td><td>- the value to compare the current value to. </td></tr>
    <tr><td class="paramname">exchangeBy</td><td>- the value to store as the the current value in case the comparison will result in equals. Otherwise, the current value will remain untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="af7922ff883503de1d13af79cbe7e715d"></a><!-- doxytag: member="atomic.hpp::CompareAndExchangeAcquire" ref="af7922ff883503de1d13af79cbe7e715d" args="(ting::s32 compareTo, ting::s32 exchangeBy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> <a class="el" href="atomic_8hpp.htm#af7922ff883503de1d13af79cbe7e715d">M_DECLARE_ALIGNED::CompareAndExchangeAcquire</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>compareTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>exchangeBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomic compare and exchange operation. </p>
<p>Compares the current value to the 'compareTo' value and if they are equal it will store the 'exchangeBy' value to the current value. It sets acquire memory semantics barrier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compareTo</td><td>- the value to compare the current value to. </td></tr>
    <tr><td class="paramname">exchangeBy</td><td>- the value to store as the the current value in case the comparison will result in equals. Otherwise, the current value will remain untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="a8beb457e5846624c3d2e8fc1d9956a28"></a><!-- doxytag: member="atomic.hpp::CompareAndExchangeRelease" ref="a8beb457e5846624c3d2e8fc1d9956a28" args="(ting::s32 compareTo, ting::s32 exchangeBy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> <a class="el" href="atomic_8hpp.htm#a8beb457e5846624c3d2e8fc1d9956a28">M_DECLARE_ALIGNED::CompareAndExchangeRelease</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>compareTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>exchangeBy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Atomic compare and exchange operation. </p>
<p>Compares the current value to the 'compareTo' value and if they are equal it will store the 'exchangeBy' value to the current value. It sets release memory semantics barrier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">compareTo</td><td>- the value to compare the current value to. </td></tr>
    <tr><td class="paramname">exchangeBy</td><td>- the value to store as the the current value in case the comparison will result in equals. Otherwise, the current value will remain untouched. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Previous value. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b9655568a9dd6b29a402c6e42c0e887"></a><!-- doxytag: member="atomic.hpp::FetchAndAdd" ref="a5b9655568a9dd6b29a402c6e42c0e887" args="(ting::s32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> <a class="el" href="atomic_8hpp.htm#a5b9655568a9dd6b29a402c6e42c0e887">M_DECLARE_ALIGNED::FetchAndAdd</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the value to this atomic variable and returns its initial value. </p>
<p>It does not set any memory barrier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value to add to this atomic variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>initial value of this atomic variable. </dd></dl>

</div>
</div>
<a class="anchor" id="ac6f76ca7faea2e43296c93756852c1a9"></a><!-- doxytag: member="atomic.hpp::FetchAndAddAcquire" ref="ac6f76ca7faea2e43296c93756852c1a9" args="(ting::s32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> <a class="el" href="atomic_8hpp.htm#ac6f76ca7faea2e43296c93756852c1a9">M_DECLARE_ALIGNED::FetchAndAddAcquire</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the value to this atomic variable and returns its initial value. </p>
<p>It sets acquire memory semantics barrier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value to add to this atomic variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>initial value of this atomic variable. </dd></dl>

</div>
</div>
<a class="anchor" id="ace2b9979e51bad5df8c3edcfa637547b"></a><!-- doxytag: member="atomic.hpp::FetchAndAddRelease" ref="ace2b9979e51bad5df8c3edcfa637547b" args="(ting::s32 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> <a class="el" href="atomic_8hpp.htm#ace2b9979e51bad5df8c3edcfa637547b">M_DECLARE_ALIGNED::FetchAndAddRelease</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the value to this atomic variable and returns its initial value. </p>
<p>It sets release memory semantics barrier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the value to add to this atomic variable. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>initial value of this atomic variable. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c982003f982bb0e493355ece02be543"></a><!-- doxytag: member="atomic.hpp::Flag" ref="a1c982003f982bb0e493355ece02be543" args="(bool initialValue=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="atomic_8hpp.htm#a1c982003f982bb0e493355ece02be543">M_DECLARE_ALIGNED::Flag</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>initialValue</em> = <code>false</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">initialValue</td><td>- initial value of the flag. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15a615a74f3e3329f9cc804a91f0dc4b"></a><!-- doxytag: member="atomic.hpp::Get" ref="a15a615a74f3e3329f9cc804a91f0dc4b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="atomic_8hpp.htm#a15a615a74f3e3329f9cc804a91f0dc4b">M_DECLARE_ALIGNED::Get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current flag value. </p>
<p>Note, that the returned value may be not actual, since the flag value can be changed in parallel. It does not set any memory barrier. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>current flag value. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b098764879fab720c0895ab3ec10da7"></a><!-- doxytag: member="atomic.hpp::Lock" ref="a5b098764879fab720c0895ab3ec10da7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="atomic_8hpp.htm#a5b098764879fab720c0895ab3ec10da7">M_DECLARE_ALIGNED::Lock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the spinlock. </p>
<p>If the lock cannot be acquired immediately it will enter a busy loop reading the lock value until it becomes 'unlocked' and then try to lock again. Right after acquiring the lock the memory barrier is set. </p>

</div>
</div>
<a class="anchor" id="af8889cad23a39a688422bd7a39cb7425"></a><!-- doxytag: member="atomic.hpp::LockYield" ref="af8889cad23a39a688422bd7a39cb7425" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="atomic_8hpp.htm#af8889cad23a39a688422bd7a39cb7425">M_DECLARE_ALIGNED::LockYield</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lock the spinlock. </p>
<p>This will do Thread::Sleep(0) in the busy loop if the lock cannot be acquired immediately. Right after acquiring the lock the memory barrier is set. </p>

</div>
</div>
<a class="anchor" id="a287b07ab58356e40b664415069dae742"></a><!-- doxytag: member="atomic.hpp::S32" ref="a287b07ab58356e40b664415069dae742" args="(ting::s32 initialValue=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="atomic_8hpp.htm#a287b07ab58356e40b664415069dae742">M_DECLARE_ALIGNED::S32</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a>&#160;</td>
          <td class="paramname"><em>initialValue</em> = <code>0</code></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">initialValue</td><td>- initial value to assign to this atomic variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e8cb0d2b3219a3298cded0fdde3426b"></a><!-- doxytag: member="atomic.hpp::Set" ref="a3e8cb0d2b3219a3298cded0fdde3426b" args="(bool value=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="atomic_8hpp.htm#a3e8cb0d2b3219a3298cded0fdde3426b">M_DECLARE_ALIGNED::Set</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the flag value. </p>
<p>Sets the flag to the new value and returns its previous value as atomic operation. It does not set any memory barrier. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the flag value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>old flag value. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4cd494ca5b8dac7d0589fbe7dfc7765"></a><!-- doxytag: member="atomic.hpp::SetAcquire" ref="ac4cd494ca5b8dac7d0589fbe7dfc7765" args="(bool value=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="atomic_8hpp.htm#ac4cd494ca5b8dac7d0589fbe7dfc7765">M_DECLARE_ALIGNED::SetAcquire</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the flag value with acquire memory semantics. </p>
<p>Sets the flag to the new value and returns its previous value as atomic operation. It sets acquire memory semantics barrier. It means that on weakly ordered architectures memory access operations which go after the <a class="el" href="atomic_8hpp.htm#ac4cd494ca5b8dac7d0589fbe7dfc7765" title="Set the flag value with acquire memory semantics.">SetAcquire()</a> will not be executed before it. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the flag value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>old flag value. </dd></dl>

</div>
</div>
<a class="anchor" id="a4074a0fc21ee0638e21297c897489a9e"></a><!-- doxytag: member="atomic.hpp::SetRelease" ref="a4074a0fc21ee0638e21297c897489a9e" args="(bool value=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="atomic_8hpp.htm#a4074a0fc21ee0638e21297c897489a9e">M_DECLARE_ALIGNED::SetRelease</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em> = <code>true</code></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the flag value with release memory semantics. </p>
<p>Sets the flag to the new value and returns its previous value as atomic operation. It sets release memory semantics barrier. It means that on weakly ordered architectures memory access operations which go before the <a class="el" href="atomic_8hpp.htm#a4074a0fc21ee0638e21297c897489a9e" title="Set the flag value with release memory semantics.">SetRelease()</a> will not be executed after it. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>- the flag value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>old flag value. </dd></dl>

</div>
</div>
<a class="anchor" id="a6ce59eb01b0e6ba0ca3f7ffbde486c40"></a><!-- doxytag: member="atomic.hpp::SpinLock" ref="a6ce59eb01b0e6ba0ca3f7ffbde486c40" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="atomic_8hpp.htm#a6ce59eb01b0e6ba0ca3f7ffbde486c40">M_DECLARE_ALIGNED::SpinLock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<p>Creates an initially unlocked spinlock. </p>

</div>
</div>
<a class="anchor" id="ae6130bfda1ed3a246f6f26c7cb42a439"></a><!-- doxytag: member="atomic.hpp::Unlock" ref="ae6130bfda1ed3a246f6f26c7cb42a439" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="atomic_8hpp.htm#ae6130bfda1ed3a246f6f26c7cb42a439">M_DECLARE_ALIGNED::Unlock</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlock the spinlock. </p>
<p>Right before releasing the lock the memory barrier is set. </p>

</div>
</div>
<a class="anchor" id="ae76479f8a15a8ecad9b0e9708f022119"></a><!-- doxytag: member="atomic.hpp::~S32" ref="ae76479f8a15a8ecad9b0e9708f022119" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="atomic_8hpp.htm#ae76479f8a15a8ecad9b0e9708f022119">M_DECLARE_ALIGNED::~S32</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a606c82003e3aa49e5baad6ad20278bbe"></a><!-- doxytag: member="atomic.hpp::flag" ref="a606c82003e3aa49e5baad6ad20278bbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile bool <a class="el" href="atomic_8hpp.htm#a606c82003e3aa49e5baad6ad20278bbe">flag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6334cfeab8b0e3af50dc82ebca4431bf"></a><!-- doxytag: member="atomic.hpp::mutex" ref="a6334cfeab8b0e3af50dc82ebca4431bf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1mt_1_1Mutex.htm">ting::mt::Mutex</a> <a class="el" href="atomic_8hpp.htm#a6334cfeab8b0e3af50dc82ebca4431bf">mutex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afe48ce163895a0bb972cda1b8046e6d9"></a><!-- doxytag: member="atomic.hpp::spinLock" ref="afe48ce163895a0bb972cda1b8046e6d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="atomic_8hpp.htm#a6ce59eb01b0e6ba0ca3f7ffbde486c40">atomic::SpinLock</a> <a class="el" href="atomic_8hpp.htm#afe48ce163895a0bb972cda1b8046e6d9">spinLock</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a06cc42a46c3f1cdf8c7f856fe28fc463"></a><!-- doxytag: member="atomic.hpp::v" ref="a06cc42a46c3f1cdf8c7f856fe28fc463" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile <a class="el" href="namespaceting.htm#a538865e72a75616abe86558cbe983026">ting::s32</a> <a class="el" href="atomic_8hpp.htm#a06cc42a46c3f1cdf8c7f856fe28fc463">v</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="atomic_8hpp.htm">atomic.hpp</a>      </li>

    <li class="footer">Generated on Thu Feb 21 2013 20:36:35 for libting by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
