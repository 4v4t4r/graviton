<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libting: ting::Ref&lt; T &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libting
   &#160;<span id="projectnumber">2.0.0</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Classes</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Class&#160;List</span></a></li>
      <li><a href="classes.htm"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.htm"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.htm"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('classting_1_1Ref.htm','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">ting::Ref&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="ting::Ref" -->
<p>Reference to a reference counted object.  
 <a href="classting_1_1Ref.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Ref_8hpp_source.htm">Ref.hpp</a>&gt;</code></p>

<p><a href="classting_1_1Ref-members.htm">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void(Ref::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a3135ef3a2d1add8a0cd3c04d54963faf">unspecified_bool_type</a> )()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A bool-like type.  <a href="#a3135ef3a2d1add8a0cd3c04d54963faf"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a0830c1a768721cd17a63beaf6112234b">StaticCast</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cast statically to another class.  <a href="#a0830c1a768721cd17a63beaf6112234b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a741825876e9978d8c1ed52318ada6597">DynamicCast</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">cast dynamically.  <a href="#a741825876e9978d8c1ed52318ada6597"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a361080c4b6f92dc9a5f46ccbd8259ded">Ref</a> (int <a class="el" href="atomic_8hpp.htm#a06cc42a46c3f1cdf8c7f856fe28fc463">v</a>=0)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor.  <a href="#a361080c4b6f92dc9a5f46ccbd8259ded"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ad259087da59626e166d42145ab09b88b">Ref</a> (T *rc)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">construct reference to given object.  <a href="#ad259087da59626e166d42145ab09b88b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a6805103bd789673cb75ffb8fe73bdbf5">Ref</a> (const <a class="el" href="classting_1_1WeakRef.htm">WeakRef</a>&lt; T &gt; &amp;r)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct reference from weak reference.  <a href="#a6805103bd789673cb75ffb8fe73bdbf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a034dbecf437679fc9861988db71fdc0a">Ref</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a> &amp;r)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a034dbecf437679fc9861988db71fdc0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a904152b4a1c644a5533cefb7c6a00fed">Ref</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for automatic down-casting and const-casting.  <a href="#a904152b4a1c644a5533cefb7c6a00fed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a48d952b3d130ea63c3c3f2e88b89361d">operator Ref&lt; const T &gt; &amp;</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast.  <a href="#a48d952b3d130ea63c3c3f2e88b89361d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a5dd7936677eadf7b7437595a6c1441aa">operator const Ref&lt; const T &gt; &amp;</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const cast.  <a href="#a5dd7936677eadf7b7437595a6c1441aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classting_1_1Ref.htm">Ref</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a7784371962da48af439c14ac8eb649f0">TakeFrom</a> (<a class="el" href="classting_1_1Ref.htm">Ref</a> &amp;ref)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Move reference.  <a href="#a7784371962da48af439c14ac8eb649f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a8064c9a044a48a1b39e99a0bc6d337b2">~Ref</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a8064c9a044a48a1b39e99a0bc6d337b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a34057d2f1182b11c7d001de31869c10e">IsValid</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells whether the reference is pointing to some object or not.  <a href="#a34057d2f1182b11c7d001de31869c10e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#af2139cd40596a24f4b9799c26c5c61e9">IsNotValid</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells whether the reference is pointing to some object or not.  <a href="#af2139cd40596a24f4b9799c26c5c61e9"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a8d4a6c7f8f5dbe898d2905f3e385a33b">operator==</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells if 2 references are equal.  <a href="#a8d4a6c7f8f5dbe898d2905f3e385a33b"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a345210f942e64f46ef421724b6584463">operator!=</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells if 2 references are not equal.  <a href="#a345210f942e64f46ef421724b6584463"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a668d36bdd18b0be140201296ef8dfa4d">operator&lt;</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two references.  <a href="#a668d36bdd18b0be140201296ef8dfa4d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ac3df590a4dcadeb74d7fdeb1ab6508ce">operator&lt;=</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two references.  <a href="#ac3df590a4dcadeb74d7fdeb1ab6508ce"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ac75157e25c75eee4c87d6b96de1aa874">operator&gt;</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two references.  <a href="#ac75157e25c75eee4c87d6b96de1aa874"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a5c609b32f5389ff017d114f958f916ca">operator&gt;=</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r) const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two references.  <a href="#a5c609b32f5389ff017d114f958f916ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ab83ac4596226fb75515ca3239de570f6">operator!</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells if the reference is invalid.  <a href="#ab83ac4596226fb75515ca3239de570f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ac7bc0c9a0d02c76553169c8bcb72e6f3">operator unspecified_bool_type</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">tells if the reference is valid.  <a href="#ac7bc0c9a0d02c76553169c8bcb72e6f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ace1da4fd1b0a5d743cb8070f91bbdf2a">Reset</a> ()  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">make this <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref</a> invalid.  <a href="#ace1da4fd1b0a5d743cb8070f91bbdf2a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classting_1_1Ref.htm">Ref</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a76847a79b4295f6bb474dc0c9c67479a">operator=</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a> &amp;r)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assign reference.  <a href="#a76847a79b4295f6bb474dc0c9c67479a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ac62d02f07ae3cb0dff6e16826b3871ba">operator=</a> (const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;r)  throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#ac62d02f07ae3cb0dff6e16826b3871ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classting_1_1WeakRef.htm">WeakRef</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a1e47ac3449920cb2d68c4a615eb106ad">GetWeakRef</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a weak reference.  <a href="#a1e47ac3449920cb2d68c4a615eb106ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#a25545e08974f2e28431f3919e65df780">operator*</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">operator *.  <a href="#a25545e08974f2e28431f3919e65df780"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classting_1_1Ref.htm#ad8761a59cd03337719708971177bfc26">operator-&gt;</a> () const   throw ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">opearator-&gt;.  <a href="#ad8761a59cd03337719708971177bfc26"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br/>
class ting::Ref&lt; T &gt;</h3>

<p>Reference to a reference counted object. </p>
<p>Pointer (reference) to a reference counted object. As soon as there is at least one <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref</a> object pointing to some reference counted object, this object will be existing. As soon as all <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref</a> objects cease to exist (going out of scope) the reference counted object they are pointing ti will be deleted. </p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3135ef3a2d1add8a0cd3c04d54963faf"></a><!-- doxytag: member="ting::Ref::unspecified_bool_type" ref="a3135ef3a2d1add8a0cd3c04d54963faf" args=")()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef void(Ref::* <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#a3135ef3a2d1add8a0cd3c04d54963faf">unspecified_bool_type</a>)()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A bool-like type. </p>
<p>This type is used instead of bool for automatic conversion of reference to this bool-like type. The advantage of using this instead of ordinary bool type is that it prevents further undesired automatic conversions to, for example, int. </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a361080c4b6f92dc9a5f46ccbd8259ded"></a><!-- doxytag: member="ting::Ref::Ref" ref="a361080c4b6f92dc9a5f46ccbd8259ded" args="(int v=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em> = <code>0</code></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>default constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>- this parameter is ignored. Its intention is just to make possible auto-conversion form int to invalid reference. This allows writing simply 'return 0;' in functions to return invalid reference. Note, any integer passed (even not 0) will result in invalid reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad259087da59626e166d42145ab09b88b"></a><!-- doxytag: member="ting::Ref::Ref" ref="ad259087da59626e166d42145ab09b88b" args="(T *rc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>rc</em></td><td>)</td>
          <td>  throw ()<code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>construct reference to given object. </p>
<p>Constructs a reference to a given reference counted object. Note, that it is supposed that first reference will be constructed right after object creation, and further work with object will only be done via <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref</a> references, not ordinary pointers. Note, that this constructor is explicit, this is done to prevent undesired automatic conversions from ordinary pointers to <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rc</td><td>- ordinary pointer to <a class="el" href="classting_1_1RefCounted.htm" title="base class for a reference counted object.">ting::RefCounted</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6805103bd789673cb75ffb8fe73bdbf5"></a><!-- doxytag: member="ting::Ref::Ref" ref="a6805103bd789673cb75ffb8fe73bdbf5" args="(const WeakRef&lt; T &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1WeakRef.htm">WeakRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Construct reference from weak reference. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- weak reference. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a034dbecf437679fc9861988db71fdc0a"></a><!-- doxytag: member="ting::Ref::Ref" ref="a034dbecf437679fc9861988db71fdc0a" args="(const Ref &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>
<p>Creates new reference object which refers to the same object as 'r'. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- existing <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> object to make copy of. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a904152b4a1c644a5533cefb7c6a00fed"></a><!-- doxytag: member="ting::Ref::Ref" ref="a904152b4a1c644a5533cefb7c6a00fed" args="(const Ref&lt; TS &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm">Ref</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor for automatic down-casting and const-casting. </p>
<p>Normally, this constructor is not supposed to be used explicitly. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- strong reference to cast. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8064c9a044a48a1b39e99a0bc6d337b2"></a><!-- doxytag: member="ting::Ref::~Ref" ref="a8064c9a044a48a1b39e99a0bc6d337b2" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::~<a class="el" href="classting_1_1Ref.htm">Ref</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a741825876e9978d8c1ed52318ada6597"></a><!-- doxytag: member="ting::Ref::DynamicCast" ref="a741825876e9978d8c1ed52318ada6597" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt;TS&gt; <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#a741825876e9978d8c1ed52318ada6597">DynamicCast</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cast dynamically. </p>
<p>Performs standard C++ dynamic_cast() operation. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>valid reference to object of casted class if dynamic_cast() succeeds, i.e. if the object can be cast to requested class. </dd>
<dd>
invalid reference otherwise, i. e. if the object cannot be cast to requested class. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e47ac3449920cb2d68c4a615eb106ad"></a><!-- doxytag: member="ting::Ref::GetWeakRef" ref="a1e47ac3449920cb2d68c4a615eb106ad" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1WeakRef.htm">WeakRef</a>&lt;T&gt; <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#a1e47ac3449920cb2d68c4a615eb106ad">GetWeakRef</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create a weak reference. </p>
<p>This is a convenience function which creates and returns a weak reference. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>weak reference created from this strong reference. </dd></dl>

</div>
</div>
<a class="anchor" id="af2139cd40596a24f4b9799c26c5c61e9"></a><!-- doxytag: member="ting::Ref::IsNotValid" ref="af2139cd40596a24f4b9799c26c5c61e9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#af2139cd40596a24f4b9799c26c5c61e9">IsNotValid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells whether the reference is pointing to some object or not. </p>
<p>Inverse of <a class="el" href="classting_1_1Ref.htm#a34057d2f1182b11c7d001de31869c10e" title="tells whether the reference is pointing to some object or not.">ting::Ref::IsValid()</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if reference is pointing to valid object. </dd>
<dd>
true if the reference does not point to any object. </dd></dl>

</div>
</div>
<a class="anchor" id="a34057d2f1182b11c7d001de31869c10e"></a><!-- doxytag: member="ting::Ref::IsValid" ref="a34057d2f1182b11c7d001de31869c10e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#a34057d2f1182b11c7d001de31869c10e">IsValid</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells whether the reference is pointing to some object or not. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if reference is pointing to valid object. </dd>
<dd>
false if the reference does not point to any object. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dd7936677eadf7b7437595a6c1441aa"></a><!-- doxytag: member="ting::Ref::operator const Ref&lt; const T &gt; &amp;" ref="a5dd7936677eadf7b7437595a6c1441aa" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; const T &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const cast. </p>
<p>'const Ref&lt;T&gt;' can automatically be cast to 'const Ref&lt;const T&gt;'. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="a48d952b3d130ea63c3c3f2e88b89361d"></a><!-- doxytag: member="ting::Ref::operator Ref&lt; const T &gt; &amp;" ref="a48d952b3d130ea63c3c3f2e88b89361d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; const T &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Const cast. </p>
<p>Automatic cast to const. 'Ref&lt;T&gt;' can automatically be cast to 'Ref&lt;const T&gt;'. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7bc0c9a0d02c76553169c8bcb72e6f3"></a><!-- doxytag: member="ting::Ref::operator unspecified_bool_type" ref="ac7bc0c9a0d02c76553169c8bcb72e6f3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator <a class="el" href="classting_1_1Ref.htm#a3135ef3a2d1add8a0cd3c04d54963faf">unspecified_bool_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells if the reference is valid. </p>
<p>This operator is a more type-safe version of conversion-to-bool operator. Usage of standard 'operator bool()' is avoided because it may lead to undesired automatic conversions to int and other types. It is intended to be used as follows: </p>
<div class="fragment"><pre class="fragment">        <a class="code" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref</a> r = TestClass::New();
        <span class="keywordflow">if</span>(r){
                <span class="comment">//r is valid.</span>
                <a class="code" href="debug_8hpp.htm#aca68c0d4ac8df0838e209fb5300f7be3">ASSERT</a>(r)
                r-&gt;DoSomethig();
        }else{
                <span class="comment">//r is invalid</span>
        }
</pre></div> 
</div>
</div>
<a class="anchor" id="ab83ac4596226fb75515ca3239de570f6"></a><!-- doxytag: member="ting::Ref::operator!" ref="ab83ac4596226fb75515ca3239de570f6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#ab83ac4596226fb75515ca3239de570f6">operator!</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells if the reference is invalid. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the reference is invalid. </dd>
<dd>
false if the reference is valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a345210f942e64f46ef421724b6584463"></a><!-- doxytag: member="ting::Ref::operator!=" ref="a345210f942e64f46ef421724b6584463" args="(const Ref&lt; TS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#ab83ac4596226fb75515ca3239de570f6">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells if 2 references are not equal. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- reference to compare this reference to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>false if both references are pointing to the same object or both are invalid. </dd>
<dd>
true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a25545e08974f2e28431f3919e65df780"></a><!-- doxytag: member="ting::Ref::operator*" ref="a25545e08974f2e28431f3919e65df780" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>operator *. </p>
<p>Works the same way as operator * for ordinary pointers. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to <a class="el" href="classting_1_1RefCounted.htm" title="base class for a reference counted object.">RefCounted</a> object pointed by this strong reference object. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8761a59cd03337719708971177bfc26"></a><!-- doxytag: member="ting::Ref::operator&#45;&gt;" ref="ad8761a59cd03337719708971177bfc26" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>opearator-&gt;. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>pointer to the <a class="el" href="classting_1_1RefCounted.htm" title="base class for a reference counted object.">RefCounted</a> object pointed by this strong reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a668d36bdd18b0be140201296ef8dfa4d"></a><!-- doxytag: member="ting::Ref::operator&lt;" ref="a668d36bdd18b0be140201296ef8dfa4d" args="(const Ref&lt; TS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two references. </p>
<p>The comparison is done the same way as it would be done for ordinary pointers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- reference to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the address of this object is less than the address of object referred by 'r'. </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3df590a4dcadeb74d7fdeb1ab6508ce"></a><!-- doxytag: member="ting::Ref::operator&lt;=" ref="ac3df590a4dcadeb74d7fdeb1ab6508ce" args="(const Ref&lt; TS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two references. </p>
<p>The comparison is done the same way as it would be done for ordinary pointers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- reference to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the address of this object is less or equal to the address of object referred by 'r'. </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a76847a79b4295f6bb474dc0c9c67479a"></a><!-- doxytag: member="ting::Ref::operator=" ref="a76847a79b4295f6bb474dc0c9c67479a" args="(const Ref &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">Ref</a>&amp; <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>assign reference. </p>
<p>Note, that if this reference was pointing to some object, the object will be destroyed if there are no other references. And this reference will be assigned a new value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- reference to assign to this reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac62d02f07ae3cb0dff6e16826b3871ba"></a><!-- doxytag: member="ting::Ref::operator=" ref="ac62d02f07ae3cb0dff6e16826b3871ba" args="(const Ref&lt; TS &gt; &amp;r)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">Ref</a>&lt;T&gt;&amp; <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>
<p>Assignment operator which also does automatic downcast and const cast if needed. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- strong reference to assign from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to this strong reference object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d4a6c7f8f5dbe898d2905f3e385a33b"></a><!-- doxytag: member="ting::Ref::operator==" ref="a8d4a6c7f8f5dbe898d2905f3e385a33b" args="(const Ref&lt; TS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>tells if 2 references are equal. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- reference to compare this reference to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if both references are pointing to the same object or both are invalid. </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac75157e25c75eee4c87d6b96de1aa874"></a><!-- doxytag: member="ting::Ref::operator&gt;" ref="ac75157e25c75eee4c87d6b96de1aa874" args="(const Ref&lt; TS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two references. </p>
<p>The comparison is done the same way as it would be done for ordinary pointers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- reference to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the address of this object is greater than the address of object referred by 'r'. </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c609b32f5389ff017d114f958f916ca"></a><!-- doxytag: member="ting::Ref::operator&gt;=" ref="a5c609b32f5389ff017d114f958f916ca" args="(const Ref&lt; TS &gt; &amp;r) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; TS &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compares two references. </p>
<p>The comparison is done the same way as it would be done for ordinary pointers. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>- reference to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if the address of this object is greater or equal to the address of object referred by 'r'. </dd>
<dd>
false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ace1da4fd1b0a5d743cb8070f91bbdf2a"></a><!-- doxytag: member="ting::Ref::Reset" ref="ace1da4fd1b0a5d743cb8070f91bbdf2a" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#ace1da4fd1b0a5d743cb8070f91bbdf2a">Reset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>make this <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref</a> invalid. </p>
<p>Resets this reference making it invalid and destroying the object it points to if necessary (if no references to the object left). </p>

</div>
</div>
<a class="anchor" id="a0830c1a768721cd17a63beaf6112234b"></a><!-- doxytag: member="ting::Ref::StaticCast" ref="a0830c1a768721cd17a63beaf6112234b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class TS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">Ref</a>&lt;TS&gt; <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#a0830c1a768721cd17a63beaf6112234b">StaticCast</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const  throw ()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>cast statically to another class. </p>
<p>Performs standard C++ static_cast(). </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>reference to object of casted class. </dd></dl>

</div>
</div>
<a class="anchor" id="a7784371962da48af439c14ac8eb649f0"></a><!-- doxytag: member="ting::Ref::TakeFrom" ref="a7784371962da48af439c14ac8eb649f0" args="(Ref &amp;ref)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classting_1_1Ref.htm">Ref</a>&amp; <a class="el" href="classting_1_1Ref.htm">ting::Ref</a>&lt; T &gt;::<a class="el" href="classting_1_1Ref.htm#a7784371962da48af439c14ac8eb649f0">TakeFrom</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classting_1_1Ref.htm">Ref</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move reference. </p>
<p>Takes reference to the object from given <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> leaving his given <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> invalid. Example: </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref&lt;Object&gt;</a> r1 = ...; <span class="comment">//let&#39;s assume r1 refers to some object.</span>
 <a class="code" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">ting::Ref&lt;Object&gt;</a> r2; <span class="comment">//r2 is invalid.</span>
 
 r2.<a class="code" href="classting_1_1Ref.htm#a7784371962da48af439c14ac8eb649f0" title="Move reference.">TakeFrom</a>(r1);
 
 <span class="comment">//at this point r1 is invalid and r2 refers to the object previously referenced by r1.</span>
</pre></div><p> In sense of performance this method is "cheaper" than simple assignment operator or copy constructor because it does not perform any atomic operations. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ref</td><td>- <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> to take object from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Reference to this <a class="el" href="classting_1_1Ref.htm" title="Reference to a reference counted object.">Ref</a> object. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="Ref_8hpp_source.htm">Ref.hpp</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceting.htm">ting</a>      </li>
      <li class="navelem"><a class="el" href="classting_1_1Ref.htm">Ref</a>      </li>

    <li class="footer">Generated on Thu Feb 21 2013 20:36:36 for libting by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
